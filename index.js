'use strict'

const debug = require('debug')('gtfs-via-postgres')
const sequencify = require('sequencify')
const readCsv = require('gtfs-utils/read-csv')
const { Stringifier } = require('csv-stringify')
const formatters = require('./lib')
const getDependencies = require('./lib/deps')
const pkg = require('./package.json')

const convertGtfsToSql = async function* (files, opt = {}) {
	opt = {
		silent: false,
		requireDependencies: false,
		ignoreUnsupportedFiles: false,
		stopsWithoutLevelId: !files.some(f => f.name === 'levels'),
		...opt,
	}
	const {
		silent,
		requireDependencies,
		ignoreUnsupportedFiles,
	} = opt

	const deps = getDependencies(opt)
	debug('deps', deps)
	if (ignoreUnsupportedFiles) {
		files = files.filter(f => !!formatters[f.name])
	}
	debug('files', files)

	const fileNames = files.map(f => f.name)
	const tasks = { // file name -> [dep name]
		'is_timezone': {
			dep: [],
		},

		// special handling of calendar/calendar_dates:
		// service_days relies on *both* calendar's & calendar_dates' tables to
		// be present, so we add mock tasks here. Each of these mock tasks get
		// replaced by a file-based one below if the file has been passed.
		'calendar': {
			dep: [],
		},
		'calendar_dates': {
			dep: [],
		},
		'service_days': {
			dep: ['calendar', 'calendar_dates'],
		},

		// The arrivals_departures & connections views rely on frequencies' table
		// to be present, so we add a mock task here. It gets replaced by a
		// file-based on below if the file has been passed.
		'frequencies': {
			dep: [...deps.frequencies],
		},
	}

	for (const file of files) {
		if (!formatters[file.name]) {
			throw new Error('invalid/unsupported file: ' + file.name)
		}

		const dependencies = deps[file.name] || []
		for (const dep of dependencies) {
			if (requireDependencies && !tasks[dep] && !fileNames.includes(dep)) {
				const err = new Error(`${file.name} depends on ${dep}`)
				err.code = 'MISSING_GTFS_DEPENDENCY'
				throw err
			}
		}

		tasks[file.name] = {
			file: file.file,
			dep: Array.from(dependencies),
		}
	}
	debug('tasks', tasks)

	const order = []
	sequencify(tasks, Object.keys(tasks), order)
	debug('order', order)

	yield `\
-- GTFS SQL dump generated by ${pkg.name} v${pkg.version}
-- ${pkg.homepage}
\\set ON_ERROR_STOP True
CREATE EXTENSION IF NOT EXISTS postgis;
CREATE SCHEMA IF NOT EXISTS "${opt.schema}";
BEGIN;

\n`

	const csv = new Stringifier({ quoted: true })

	for (const name of order) {
		if (!silent) console.error(name)
		const task = tasks[name]
		yield `-- ${name}\n-----------------\n\n`

		const {
			beforeAll,
			afterAll,
		} = formatters[name]

		if ('string' === typeof beforeAll && beforeAll) {
			yield beforeAll
		} else if ('function' === typeof beforeAll) {
			yield beforeAll(opt)
		}

		if (task.file) {
			const { formatRow } = formatters[name]
			for await (const row of await readCsv(task.file)) {
				const formatted = csv.stringify(formatRow(row, opt))
				yield formatted + '\n'
			}
		}

		if ('string' === typeof afterAll && afterAll) {
			yield afterAll + ';\n'
		} else if ('function' === typeof afterAll) {
			yield afterAll(opt) + ';\n'
		}
	}

	yield `\
COMMIT;`
}

module.exports = convertGtfsToSql
